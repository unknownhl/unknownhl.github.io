{"meta":{"title":"HL","subtitle":"","description":"黄黎的博客","author":"黄黎","url":"https://unknownhl.github.io","root":"/"},"pages":[{"title":"about","date":"2022-05-26T08:08:30.000Z","updated":"2022-05-26T08:08:30.678Z","comments":true,"path":"about/index.html","permalink":"https://unknownhl.github.io/about/index.html","excerpt":"","text":""},{"title":"code","date":"2022-05-26T08:07:06.000Z","updated":"2022-05-26T08:07:06.254Z","comments":true,"path":"code/index.html","permalink":"https://unknownhl.github.io/code/index.html","excerpt":"","text":""},{"title":"document","date":"2022-05-26T08:06:42.000Z","updated":"2022-05-26T08:06:42.073Z","comments":true,"path":"document/index.html","permalink":"https://unknownhl.github.io/document/index.html","excerpt":"","text":""}],"posts":[{"title":"数据体系建设","slug":"数据体系建设","date":"2022-05-30T07:20:28.000Z","updated":"2022-05-31T05:40:22.234Z","comments":true,"path":"2022/05/30/数据体系建设/","link":"","permalink":"https://unknownhl.github.io/2022/05/30/%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE/","excerpt":"《数据中台–让数据用起来》一书中的数据体系建设。 数据中台数据体系是在全域原始数据的基础上，进行标准定义及分层建模，数据体系建设最终呈现的结果是一套完整、规范、准确的数据体系，可以方便支撑数据应用。","text":"《数据中台–让数据用起来》一书中的数据体系建设。 数据中台数据体系是在全域原始数据的基础上，进行标准定义及分层建模，数据体系建设最终呈现的结果是一套完整、规范、准确的数据体系，可以方便支撑数据应用。 中台数据体系的特征：覆盖全域数据、结构层次清晰、数据准确一致、性能提升、降低成本和方便易用。 数据体系架构是一套指导规范，实施过程中应严格按照架构执行。层次大概有贴源数据层（ods）、统一数仓层（dw）、标签数据层（tdm）、应用数据层（ads）。贴源数据层仅做业务数据的同步与存储，应用数据层面向特定业务组装数据，这两层没有太多的建模规范，重点介绍统一数仓层和标签数据层的建设。 贴源数据层贴源数据层也称操作数据层，是数据体系架构中最接近数据源的一层，是全企业业务数据的集中存储处，除了对非结构化数据进行结构化处理以及对相同数据进行整合外，并不对业务数据做过多的清洗加工，尽可能保留数据的原始状态。贴源数据层建设的目标就是把企业的全域原始数据都汇聚到数据中台，从而能在数据中台查询到所有的企业数据，为后面的统一数仓层、标签数据层、应用数据层建设做准备。建议从传统的E（抽取）T（转换）L（加载）的过程转为ELT方式。 一般采用数据同步工具实现数据的同步落地，具体实现步骤如下： （1）确定业务系统源表与贴源数据层目标表； （2）配置数据字段映射关系，目标表可能会增加采集日期、分区、原系统标识等必要信息，业务相关内容不做转换； （3）如果是增量同步或者有条件地同步部分数据，则配置数据同步条件； （4）清理目标表对应数据； （5）启动同步任务，往贴源数据层目标表导入数据； （6）验证任务是否可以正确运行，并且采集到准确数据； （7）发布采集任务，加入生产调度，并配置相关限速、容错、质量监控、告警机制。 统一数仓层—标准化的数据底座统一数仓层站在业务的视角，不考虑业务系统流程，从业务完整性的角度重新组织数据。统一数仓层的目标是建设一套覆盖全域、全历史的企业数据体系，利用这套数据体系可以还原企业任意时刻的业务运转状态。有范式建模、维度建模和实体建模三种建模方式。 统一数仓层建设过程以维度建模为理论基础，构建总线矩阵，划分业务板块，定义数据域、业务过程、维度、原子指标、修饰类型、修饰词、时间周期、派生指标，进而确定维度表、事实表的模型设计。 业务板块：根据业务的属性划分出的相对独立的业务板块。 模型设计：以建模理论为基础，基于维度建模总线架构，构建一致性的维度和事实，同时设计出一套表命名规范。 数据域：数据域是统一数仓层的顶层划分，是一个较高层次的数据归类标准，是对企业业务过程进行抽象、提炼、组合的集合。 业务过程：业务过程是一种企业的业务活动事件，且是企业经营过程中不可拆分的行为事件。业务过程产生度量，并且会被转换为最终的事实表中的事实。 修饰词：修饰词指除维度以外的对指标进行限定抽象的业务场景词语，修饰词隶属于一个修饰类型。比如，在日志域的访问类型下，有修饰词PC、无线端。 原子指标：原子指标是针对某一业务事件行为的度量，是一种不可拆分的指标，具有明确业务含义，比如支付金额。原子指标有确定的字段名称、数据类型、算法说明、所属数据域和业务过程。原子指标名称一般采用“动作+度量”方式命名，比如支付金额、注册用户数。 派生指标：派生指标可以理解为对原子指标业务统计范围的圈定，比如最近一天北京买家支付金额（“最近一天”是时间周期，“北京”是修饰词，修饰词“买家”是维度）。派生指标&#x3D;1个原子指标+多个修饰词+时间修饰词。 计算方法：指标的数学计算方式，比如汇总、平均、最大、最小等。 维度表：维度是观察事物的角度，提供某一业务过程事件所涉及的用于过滤及分类事实的描述性属性，用于描述“谁、什么、哪里、何时、为什么、如何”（5W1H）有关的事件。比如“早上黄黎在食堂花费5元钱购买了一碗小面”，以购买为业务过程进行分析，可从这段信息中提取三个维度，即时间维度（早上）、地点维度（食堂）和商品维度（小面）。维度表是统一设计的，在整个数据仓库中共享，所有数据域、业务过程都需要用到维度，都可以在公共维度表中获取相关维度属性。 事实表：事实是观察事物得到的事实数据，事实涉及来自业务过程事件的度量，基本都是以数量值表示，比如一次购买行为就可以理解为是一个事实，5元就是事实信息。在确定数据域与业务过程后，就可以根据业务过程涉及的维度、度量及粒度，涉及相关的事实表。事实表不跨数据域，根据需要，一个事实表可能对应同数据域下一个或者多个业务过程。事实表又分为明细事实表和汇总事实表。明细事实表记录事物层面的事实，保存的是原子数据，数据的粒度通常是每个事务一条记录，明细事实表数据被插入，数据就不再进行更改，其更新方式为增量更新。汇总事实表是把明细事实聚合形成的事实表，包括以具有规律性的、可预见的时间间隔来记录事实的周期快照事实表和以不确定的周期来记录事实的累计快照事实表。 粒度：粒度是指统一数仓层数据的细化或者综合程度，对各事实表行实际代表的内容给出明确的说明，用于确定某一事实表中的行表示什么。确定维度或者事实之前必须声明粒度，因为每个维度和事实都必须与定义的粒度保持一致。原子粒度是最低级别的粒度，是对业务过程最详细的刻画，原子粒度事实必须保留。 一致性指标定义：指标归属到具体的数据域，定义指标的含义、命名、类型、计算方法，确保指标的全局一致性。 统一数仓层落地实施的具体步骤如下： （1）按照命名规范创建表，包括维度表和事实表； （2）开发生成维表和事实表的数据的逻辑代码； （3）进行代码逻辑测试，验证数据加工逻辑的正确性； （4）代码发布，加入生产调度，并配置相应的质量监控和报警机制； （5）持续任务运维监控。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://unknownhl.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"数据中台","slug":"数据中台","permalink":"https://unknownhl.github.io/tags/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/"}],"author":"黄黎"},{"title":"理解attention","slug":"理解attention","date":"2022-05-29T06:29:32.000Z","updated":"2022-05-29T06:57:37.613Z","comments":true,"path":"2022/05/29/理解attention/","link":"","permalink":"https://unknownhl.github.io/2022/05/29/%E7%90%86%E8%A7%A3attention/","excerpt":"知乎上的一篇文章，记录一下 Attention 思路：“带权求和”就可以高度概括","text":"知乎上的一篇文章，记录一下 Attention 思路：“带权求和”就可以高度概括 一文看懂 Attention（本质原理+3大优点+5大类型） Encoder-Decoder 和 Seq2Seq nlp学习网站","categories":[{"name":"nlp","slug":"nlp","permalink":"https://unknownhl.github.io/categories/nlp/"}],"tags":[{"name":"attention","slug":"attention","permalink":"https://unknownhl.github.io/tags/attention/"}],"author":"黄黎"},{"title":"Predicting issue types on GitHub","slug":"Predicting-issue-types-on-GitHub","date":"2022-05-26T09:05:42.000Z","updated":"2022-05-28T08:21:00.002Z","comments":true,"path":"2022/05/26/Predicting-issue-types-on-GitHub/","link":"","permalink":"https://unknownhl.github.io/2022/05/26/Predicting-issue-types-on-GitHub/","excerpt":"Ticket Tagger可以为GitHub项目上的问题自动分配合适的标签，它的核心是一个机器学习模型，通过分析问题的标题和文本描述，以确定该问题是否可以被标记为bug、enhancement和question。具体方法为fastText，baseline为J48，它是一个决策树机器学习算法。该篇文章2021年发表在Science of Computer Programming。原文链接","text":"Ticket Tagger可以为GitHub项目上的问题自动分配合适的标签，它的核心是一个机器学习模型，通过分析问题的标题和文本描述，以确定该问题是否可以被标记为bug、enhancement和question。具体方法为fastText，baseline为J48，它是一个决策树机器学习算法。该篇文章2021年发表在Science of Computer Programming。原文链接 摘要Ticket Tagger通过机器学习技术分析问题的标题和描述，自动识别在GitHub上提交的报告类型，并相应地给每个问题分配标签 背景为了减轻代码潜在的失败，问题追踪系统Issue tracking systems被用于有效地标记，管理和解决软件系统中出现的tickets或潜在问题，并被要求及时反馈。而在实际的GitHub项目中，问题提交者简答提供问题标题和描述就可创建一条问题报告，GitHub提供定制化的标签系统标记问题报告，这样有两个好处，一是具有更好的管理和优先级，二是可以分类和筛选问题报告。问题就是费时费力容易出错。 为了帮助维护者处理问题，我们开发了Ticket Tagger，一个能够自动标记问题报告的工具。与之前旨在自动识别问题类型的方法不同，由于GitHub（根据其轻量级结构）不提供任何关于此类问题的结构化信息，我们的工具完全依赖于报告的标题和描述中包含的文本特征，以便在报告提交后立即对其进行自动标记。这对有兴趣处理新问题的开发者来说是有益的。评估了使用不同的机器学习策略所取得的分类性能，并研究了不同类型的混杂因素在多大程度上会降低分类结果。 方法选择fastText，这是一个使用线性模型的工具，具有等级约束和快速损失近似，能够实现与几个基于深度学习的方法相当的分类结果。 问题报告预处理和矢量表示法 为了让fastText线性分类器进行问题类型预测，报告的标题和正文被串联成一个文本段落。然后对所得文本进行标记，标记后的文本是获得问题的词包表示的来源。这个词包表示，其中每个词都由一个n-grams字符向量表示，是基于fastText的分类器的输入。 问题分类 fastText模型通过在N个可能的标签上最小化以下目标函数对问题进行分类。$$-\\frac{1}{N}\\sum_{n&#x3D;1}^{N}{y_n}{log(f(BA\\chi_n))}$$其中，xn是一个特征包，A代表平均文本嵌入的权重字典，B是将嵌入转换为每个类别的预软化值的权重字典，f是用于最小化计算复杂性的分层softmax函数。 通过使用大多数参数的默认值来设置fastText，并应用了以下定制。 不捕捉词的n-gram特征，即wordNgrams参数。只考虑在数据集中至少出现14次的词，即minCount参数。 这两种设置都是根据服务器硬件的磁盘限制来应用的。事实上，这些决定使我们能够获得一个需要不到5MB磁盘空间的训练模型，同时只施加了&lt;10%的性能损失。 Ticket Tagger 目前能够根据反映作者意图的三个类别对问题进行分类：bug report, enhancement, and question。这些标签被默认包含在每个GitHub仓库中，它们是GitHub上使用最多的三个标签。显然，模型被设计成可以很容易地重新训练，以使Ticket Tagger适应特定项目的需要，从而实现对更多问题类型的预测。 当一个新的问题报告被提交到安装了Ticket Tagger的GitHub仓库时，该工具会自动为新报告分配一个相关标签。具体来说，Ticket Tagger是一个基于Node.js的GitHub应用程序，它可以自动（i）从GitHub仓库收集问题报告信息（ii）利用之前讨论的预训练的fastText模型，为新报告的问题贴上标签。该应用可以免费使用，并且可以很容易地安装到任何现有的GitHub仓库。通过浏览Ticket Tagger应用的网页，要在目标仓库上安装Ticket Tagger，仓库管理员必须点击 “安装 “按钮，指定仓库，就可以了。从这一刻起，如图 1 所示，当用户在仓库中打开一个新的问题时，GitHub 会调用 Ticket Tagger 所暴露的hook endpoint，并引用与新创建问题相关的信息。这些信息被应用程序用来对票据进行分类。为了给问题报告自动贴上标签，GitHub为Ticket Tagger提供了一个临时访问令牌，通过给问题分配预测的标签来消耗该令牌。由Ticket Tagger执行的自动问题标签允许开发者(i)及时对紧急问题做出反应，(ii)推迟不那么急迫的任务（如增强请求），或(iii)将问题分配给特定用户。 评估数据集构建 为了评估Ticket Tagger对GitHub问题的分类效果，论文收集了两个数据集。第一个数据集D_balanced，包含30,000个问题。这个数据集首先从12,112个异质项目中收集问题，这是用Google BigQuery查询GitHub档案获得的。在这个初始步骤之后，论文从2018年2月期间关闭的所有GitHub问题集中随机抽出问题，从而选择所有标签与以下字符串匹配的问题：bug report, enhancement, and question。通过这个随机选择过程，我们平均为每个项目选择了2.48个问题（中位数&#x3D;1，标准差&#x3D;15.78）。在30,000个问题中，有三分之一的问题被分配了bug标签；三分之一的问题被分配了enhancement标签；而剩下的10,000个问题被分配了question标签。为了构建第二个数据集，D_unbalanced，论文使用Google BigQuery对GitHub Archive进行了一次查询，查询了GitHub Archive中2018年3月1日至9日期间包含三个标签中任何一个的问题，即bug、enhancement和question，获得了大约34000个问题。16,355（48%）被标记为bug，14,228（41.8%）被标记为增强，3,458（10.2%）问题。第一个数据集，D_balanced，包含每个类别的相同数量的票据，而第二个数据集，D_unbalanced，呈现出标签的不平衡分布，更能代表现实。 评估方法 实验的目的有两个方面。一方面，将Ticker Tagger与一个基线方法进行比较，以观察更简单的基于ML的方法是否能够取得与Ticker Tagger相当或更好的结果。另一方面，评估Ticket Tagger在多大程度上能够自动识别正确的标签，以分配给现实场景中的问题报告。更具体地说，将Ticket Tagger与J48机器学习（ML）算法进行比较，该算法在以前有关评估文本分类问题的ML策略的工作中被成功使用。为了进行这样的比较，在D_balanced上采用了10折交叉验证策略来评估Ticket Tagger和基线J48 ML算法取得的分类性能。为了训练J48模型，利用数据集中问题的标题和描述中包含的所有术语来建立一个document-term矩阵M，其中每一行代表数据集中的一个问题，每一列代表一个术语。上述矩阵中的每个条目Mij代表第i个问题中第j个术语的权重或重要性，根据tf-idf加权方案计算，该方案在最近关于GitHub问题和漏洞的分类工作中已经成功使用。值得注意的是，为了确保两个模型之间的公平比较，在应用 J48 时，论文没有进行任何模型的调整和数据的预处理，因为 fastText 也是以同样的方式使用。此外，评估是在没有用于减少fastText的磁盘空间的自定义设置的情况下进行的（在第二节中描述）。为了评估Ticket Tagger在现实环境中识别问题类型的能力，即问题类型的不平衡分布，论文进行了进一步的实验，其中Ticket Tagger在整个平衡数据集D_balanced上进行训练，而不平衡数据集D_unbalanced则被用于评估分类性能。这种特殊的设置，即平衡的训练集和不平衡的测试集，是由于需要避免所产生的模型偏向于大多数类别。著名的信息检索指标，即精度、召回率和F-measure，在我们的实验中被用来评估分类性能。 对混杂因素的讨论 1.功能词的影响。对于属于bug和enhancement类别的问题，精确度和召回率都在0.70以上，而Ticket Tagger对question类别产生了更多的假阳性和假阴性，也就是说，对于这个类别，精确度和召回率都比较低。我们认为，在问题的标题或描述中大量使用功能词，例如 “如何 “或 “什么”，这些词通常会引入question，这可能导致分类器错误地将问题标签分配给实际上属于不同类别的问题，因此，这降低了问题类别的精度。此外，这个类别的召回率较低，这可能与开发人员（和用户）对广泛的主题提出问题有关，这使得我们很难学习所有可能导致分配这个标签的模式。 2.问题的语言一致性的影响：我们观察issue的语言是否会影响我们模型的性能。因此，我们生成了两个数据集，一个包含24,600个issue，另一个是由24,600个issue组成的基线数据集，其中的随机issue采用了在数据集构建部分描述的相同策略。为了生成包含24,600张英文issue的数据集，我们使用了一个guess language的javascript端口，这是一个使用基于字符集和trigrams的启发式工具来自动检测文本的语言。结果表明，问题单中的语言一致性对分类性能有积极影响。 3.问题中的代码片段的存在：我们观察问题中的代码片段的存在是否会影响我们模型的表现。因此，我们产生了两个数据集，一个是含有代码片段的6000个issue，另一个是使用前面提到的方法随机抽样的6000个issue的基线数据集。特别是，代码片段的存在是通过检测包含在三重反斜线中的文本片段来识别的，这是GitHub Flavored Markdownlanguage推荐的特殊语法，用于突出代码片段。结果显示，代码片段的存在并没有明显影响分类性能。 结论在这项工作中，我们提出了Ticket Tagger，这是我们在GitHub市场上发布的一个应用，它可以为GitHub项目上的问题自动分配合适的标签。Ticket Tagger的核心是一个机器学习模型，它分析问题的标题和文本描述，以确定该问题是否可以被标记为错误报告、功能请求或问题。为了评估我们的工具所取得的分类性能，我们进行了四个主要的评估实验。评估结果表明，Ticket Tagger能够以相当高的精度和召回率自动分配标签，其结果优于基线方法。我们的研究结果还表明，使用一致的语言可以提高Ticket Tagger的分类性能，而代码片段的存在并不影响结果。未来的工作旨在（i）将Ticket Tagger的准确性和功能与其他现有的解决方案进行比较，以及（ii）通过分析终端用户的直接反馈来研究其实用性。","categories":[{"name":"论文","slug":"论文","permalink":"https://unknownhl.github.io/categories/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"issue report label","slug":"issue-report-label","permalink":"https://unknownhl.github.io/tags/issue-report-label/"}],"author":"黄黎"}],"categories":[{"name":"大数据","slug":"大数据","permalink":"https://unknownhl.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"nlp","slug":"nlp","permalink":"https://unknownhl.github.io/categories/nlp/"},{"name":"论文","slug":"论文","permalink":"https://unknownhl.github.io/categories/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"数据中台","slug":"数据中台","permalink":"https://unknownhl.github.io/tags/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/"},{"name":"attention","slug":"attention","permalink":"https://unknownhl.github.io/tags/attention/"},{"name":"issue report label","slug":"issue-report-label","permalink":"https://unknownhl.github.io/tags/issue-report-label/"}]}